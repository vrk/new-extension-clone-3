{"entries":[{"timestamp":1725035138567,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/**\n * Well known colors for a NeoPixel strip\n */\nenum NeoPixelColors {\n    //% block=red\n    Red = 0xFF0000,\n    //% block=orange\n    Orange = 0xFFA500,\n    //% block=yellow\n    Yellow = 0xFFFF00,\n    //% block=green\n    Green = 0x00FF00,\n    //% block=blue\n    Blue = 0x0000FF,\n    //% block=indigo\n    Indigo = 0x4b0082,\n    //% block=violet\n    Violet = 0x8a2be2,\n    //% block=purple\n    Purple = 0xFF00FF,\n    //% block=white\n    White = 0xFFFFFF,\n    //% block=black\n    Black = 0x000000\n}\n\n/**\n * Different modes for RGB or RGB+W NeoPixel strips\n */\nenum NeoPixelMode {\n    //% block=\"RGB (GRB format)\"\n    RGB = 1,\n    //% block=\"RGB+W\"\n    RGBW = 2,\n    //% block=\"RGB (RGB format)\"\n    RGB_RGB = 3\n}\n\n/**\n * Functions to operate NeoPixel strips.\n */\n//% weight=5 color=#2699BF icon=\"\\uf110\"\nnamespace neopixel {\n    /**\n     * A NeoPixel strip\n     */\n    export class Strip {\n        buf: Buffer;\n        pin: DigitalPin;\n        // TODO: encode as bytes instead of 32bit\n        brightness: number;\n        start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _matrixWidth: number; // number of leds in a matrix - if any\n\n        /**\n         * Shows all LEDs to a given color (range 0-255 for r, g, b).\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"%strip|show color %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showColor(rgb: number) {\n            rgb = rgb >> 0;\n            this.setAllRGB(rgb);\n            this.show();\n        }\n\n        /**\n         * Shows a rainbow pattern on all LEDs.\n         * @param startHue the start hue value for the rainbow, eg: 1\n         * @param endHue the end hue value for the rainbow, eg: 360\n         */\n        //% blockId=\"neopixel_set_strip_rainbow\" block=\"%strip|show rainbow from %startHue|to %endHue\"\n        //% strip.defl=strip\n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n            if (this._length <= 0) return;\n\n            startHue = startHue >> 0;\n            endHue = endHue >> 0;\n            const saturation = 100;\n            const luminance = 50;\n            const steps = this._length;\n            const direction = HueInterpolationDirection.Clockwise;\n\n            //hue\n            const h1 = startHue;\n            const h2 = endHue;\n            const hDistCW = ((h2 + 360) - h1) % 360;\n            const hStepCW = Math.idiv((hDistCW * 100), steps);\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n            let hStep: number;\n            if (direction === HueInterpolationDirection.Clockwise) {\n                hStep = hStepCW;\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n                hStep = hStepCCW;\n            } else {\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n            }\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n            //sat\n            const s1 = saturation;\n            const s2 = saturation;\n            const sDist = s2 - s1;\n            const sStep = Math.idiv(sDist, steps);\n            const s1_100 = s1 * 100;\n\n            //lum\n            const l1 = luminance;\n            const l2 = luminance;\n            const lDist = l2 - l1;\n            const lStep = Math.idiv(lDist, steps);\n            const l1_100 = l1 * 100\n\n            //interpolate\n            if (steps === 1) {\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n            } else {\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n                for (let i = 1; i < steps - 1; i++) {\n                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;\n                    const s = Math.idiv((s1_100 + i * sStep), 100);\n                    const l = Math.idiv((l1_100 + i * lStep), 100);\n                    this.setPixelColor(i, hsl(h, s, l));\n                }\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n            }\n            this.show();\n        }\n\n        /**\n         * Displays a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, eg: 255\n         */\n        //% weight=84\n        //% blockId=neopixel_show_bar_graph block=\"%strip|show bar graph of %value|up to %high\"\n        //% strip.defl=strip\n        //% icon=\"\\uf080\"\n        //% parts=\"neopixel\"\n        showBarGraph(value: number, high: number): void {\n            if (high <= 0) {\n                this.clear();\n                this.setPixelColor(0, NeoPixelColors.Yellow);\n                this.show();\n                return;\n            }\n\n            value = Math.abs(value);\n            const n = this._length;\n            const n1 = n - 1;\n            let v = Math.idiv((value * n), high);\n            if (v == 0) {\n                this.setPixelColor(0, 0x666600);\n                for (let i = 1; i < n; ++i)\n                    this.setPixelColor(i, 0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i <= v) {\n                        const b = Math.idiv(i * 255, n1);\n                        this.setPixelColor(i, neopixel.rgb(b, 0, 255 - b));\n                    }\n                    else this.setPixelColor(i, 0);\n                }\n            }\n            this.show();\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b).\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"%strip|set pixel color at %pixeloffset|to %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelColor(pixeloffset: number, rgb: number): void {\n            this.setPixelRGB(pixeloffset >> 0, rgb >> 0);\n        }\n\n        /**\n         * Sets the number of pixels in a matrix shaped strip\n         * @param width number of pixels in a row\n         */\n        //% blockId=neopixel_set_matrix_width block=\"%strip|set matrix width %width\"\n        //% strip.defl=strip\n        //% blockGap=8\n        //% weight=5\n        //% parts=\"neopixel\" advanced=true\n        setMatrixWidth(width: number) {\n            this._matrixWidth = Math.min(this._length, width >> 0);\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b) in a matrix shaped strip\n         * You need to call ``show`` to make the changes visible.\n         * @param x horizontal position\n         * @param y horizontal position\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_matrix_color\" block=\"%strip|set matrix color at x %x|y %y|to %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% weight=4\n        //% parts=\"neopixel\" advanced=true\n        setMatrixColor(x: number, y: number, rgb: number) {\n            if (this._matrixWidth <= 0) return; // not a matrix, ignore\n            x = x >> 0;\n            y = y >> 0;\n            rgb = rgb >> 0;\n            const cols = Math.idiv(this._length, this._matrixWidth);\n            if (x < 0 || x >= this._matrixWidth || y < 0 || y >= cols) return;\n            let i = x + y * this._matrixWidth;\n            this.setPixelColor(i, rgb);\n        }\n\n        /**\n         * For NeoPixels with RGB+W LEDs, set the white LED brightness. This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"neopixel_set_pixel_white\" block=\"%strip|set pixel white LED at %pixeloffset|to %white\"\n        //% strip.defl=strip\n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode === NeoPixelMode.RGBW) {\n                this.setPixelW(pixeloffset >> 0, white >> 0);\n            }\n        }\n\n        /**\n         * Send all the changes to the strip.\n         */\n        //% blockId=\"neopixel_show\" block=\"%strip|show\" blockGap=8\n        //% strip.defl=strip\n        //% weight=79\n        //% parts=\"neopixel\"\n        show() {\n            // only supported in beta\n            // ws2812b.setBufferMode(this.pin, this._mode);\n            // ws2812b.sendBuffer(this.buf, this.pin);\n        }\n\n        /**\n         * Turn off all LEDs.\n         * You need to call ``show`` to make the changes visible.\n         */\n        //% blockId=\"neopixel_clear\" block=\"%strip|clear\"\n        //% strip.defl=strip\n        //% weight=76\n        //% parts=\"neopixel\"\n        clear(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.fill(0, this.start * stride, this._length * stride);\n        }\n\n        /**\n         * Gets the number of pixels declared on the strip\n         */\n        //% blockId=\"neopixel_length\" block=\"%strip|length\" blockGap=8\n        //% strip.defl=strip\n        //% weight=60 advanced=true\n        length() {\n            return this._length;\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 255\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"%strip|set brightness %brightness\" blockGap=8\n        //% strip.defl=strip\n        //% weight=59\n        //% parts=\"neopixel\" advanced=true\n        setBrightness(brightness: number): void {\n            this.brightness = brightness & 0xff;\n        }\n\n        /**\n         * Apply brightness to current colors using a quadratic easing function.\n         **/\n        //% blockId=\"neopixel_each_brightness\" block=\"%strip|ease brightness\" blockGap=8\n        //% strip.defl=strip\n        //% weight=58\n        //% parts=\"neopixel\" advanced=true\n        easeBrightness(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const br = this.brightness;\n            const buf = this.buf;\n            const end = this.start + this._length;\n            const mid = Math.idiv(this._length, 2);\n            for (let i = this.start; i < end; ++i) {\n                const k = i - this.start;\n                const ledoffset = i * stride;\n                const br = k > mid\n                    ? Math.idiv(255 * (this._length - 1 - k) * (this._length - 1 - k), (mid * mid))\n                    : Math.idiv(255 * k * k, (mid * mid));\n                const r = (buf[ledoffset + 0] * br) >> 8; buf[ledoffset + 0] = r;\n                const g = (buf[ledoffset + 1] * br) >> 8; buf[ledoffset + 1] = g;\n                const b = (buf[ledoffset + 2] * br) >> 8; buf[ledoffset + 2] = b;\n                if (stride == 4) {\n                    const w = (buf[ledoffset + 3] * br) >> 8; buf[ledoffset + 3] = w;\n                }\n            }\n        }\n\n        /**\n         * Create a range of LEDs.\n         * @param start offset in the LED strip to start the range\n         * @param length number of LEDs in the range. eg: 4\n         */\n        //% weight=89\n        //% blockId=\"neopixel_range\" block=\"%strip|range from %start|with %length|leds\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\"\n        //% blockSetVariable=range\n        range(start: number, length: number): Strip {\n            start = start >> 0;\n            length = length >> 0;\n            let strip = new Strip();\n            strip.buf = this.buf;\n            strip.pin = this.pin;\n            strip.brightness = this.brightness;\n            strip.start = this.start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);\n            strip._matrixWidth = 0;\n            strip._mode = this._mode;\n            return strip;\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"neopixel_shift\" block=\"%strip|shift pixels by %offset\" blockGap=8\n        //% strip.defl=strip\n        //% weight=40\n        //% parts=\"neopixel\"\n        shift(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.shift(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Rotate LEDs forward.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to rotate forward, eg: 1\n         */\n        //% blockId=\"neopixel_rotate\" block=\"%strip|rotate pixels by %offset\" blockGap=8\n        //% strip.defl=strip\n        //% weight=39\n        //% parts=\"neopixel\"\n        rotate(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.rotate(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Set the pin where the neopixel is connected, defaults to P0.\n         */\n        //% weight=10\n        //% parts=\"neopixel\" advanced=true\n        setPin(pin: DigitalPin): void {\n            this.pin = pin;\n            pins.digitalWritePin(this.pin, 0);\n            // don't yield to avoid races on initialization\n        }\n\n        /**\n         * Estimates the electrical current (mA) consumed by the current light configuration.\n         */\n        //% weight=9 blockId=neopixel_power block=\"%strip|power (mA)\"\n        //% strip.defl=strip\n        //% advanced=true\n        power(): number {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const end = this.start + this._length;\n            let p = 0;\n            for (let i = this.start; i < end; ++i) {\n                const ledoffset = i * stride;\n                for (let j = 0; j < stride; ++j) {\n                    p += this.buf[i + j];\n                }\n            }\n            return Math.idiv(this.length() * 7, 10) /* 0.7mA per neopixel */\n                + Math.idiv(p * 480, 10000); /* rought approximation */\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n                this.buf[offset + 0] = red;\n                this.buf[offset + 1] = green;\n            } else {\n                this.buf[offset + 0] = green;\n                this.buf[offset + 1] = red;\n            }\n            this.buf[offset + 2] = blue;\n        }\n\n        private setAllRGB(rgb: number) {\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            const br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            const end = this.start + this._length;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            for (let i = this.start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n        }\n        private setAllW(white: number) {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            let end = this.start + this._length;\n            for (let i = this.start; i < end; ++i) {\n                let ledoffset = i * 4;\n                buf[ledoffset + 3] = white;\n            }\n        }\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            let stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            pixeloffset = (pixeloffset + this.start) * stride;\n\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            let br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            this.setBufferRGB(pixeloffset, red, green, blue)\n        }\n        private setPixelW(pixeloffset: number, white: number): void {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            buf[pixeloffset + 3] = white;\n        }\n    }\n\n    /**\n     * Create a new NeoPixel driver for `numleds` LEDs.\n     * @param pin the pin where the neopixel is connected.\n     * @param numleds number of leds in the strip, eg: 24,30,60,64\n     */\n    //% blockId=\"neopixel_create\" block=\"NeoPixel at pin %pin|with %numleds|leds as %mode\"\n    //% weight=90 blockGap=8\n    //% parts=\"neopixel\"\n    //% trackArgs=0,2\n    //% blockSetVariable=strip\n    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {\n        let strip = new Strip();\n        let stride = mode === NeoPixelMode.RGBW ? 4 : 3;\n        strip.buf = pins.createBuffer(numleds * stride);\n        strip.start = 0;\n        strip._length = numleds;\n        strip._mode = mode || NeoPixelMode.RGB;\n        strip._matrixWidth = 0;\n        strip.setBrightness(128)\n        strip.setPin(pin)\n        return strip;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% weight=1\n    //% blockId=\"neopixel_rgb\" block=\"red %red|green %green|blue %blue\"\n    //% advanced=true\n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    /**\n     * Gets the RGB value of a known color\n    */\n    //% weight=2 blockGap=8\n    //% blockId=\"neopixel_colors\" block=\"%color\"\n    //% advanced=true\n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n    function unpackB(rgb: number): number {\n        let b = (rgb) & 0xFF;\n        return b;\n    }\n\n    /**\n     * Converts a hue saturation luminosity value into a RGB color\n     * @param h hue from 0 to 360\n     * @param s saturation from 0 to 99\n     * @param l luminosity from 0 to 99\n     */\n    //% blockId=neopixelHSL block=\"hue %h|saturation %s|luminosity %l\"\n    export function hsl(h: number, s: number, l: number): number {\n        h = Math.round(h);\n        s = Math.round(s);\n        l = Math.round(l);\n\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n        let h1 = Math.idiv(h, 60);//[0,6]\n        let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\n        let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\n        let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h1 == 0) {\n            r$ = c; g$ = x; b$ = 0;\n        } else if (h1 == 1) {\n            r$ = x; g$ = c; b$ = 0;\n        } else if (h1 == 2) {\n            r$ = 0; g$ = c; b$ = x;\n        } else if (h1 == 3) {\n            r$ = 0; g$ = x; b$ = c;\n        } else if (h1 == 4) {\n            r$ = x; g$ = 0; b$ = c;\n        } else if (h1 == 5) {\n            r$ = c; g$ = 0; b$ = x;\n        }\n        let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\n        let r = r$ + m;\n        let g = g$ + m;\n        let b = b$ + m;\n        return packRGB(r, g, b);\n    }\n\n    export enum HueInterpolationDirection {\n        Clockwise,\n        CounterClockwise,\n        Shortest\n    }\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":21132,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"lone"],[-1,"--no-gh-linked"],[0,"\",\n "]],"start1":30,"start2":30,"length1":22,"length2":8},{"diffs":[[0,"  \"main."],[-1,"t"],[1,"block"],[0,"s\",\n    "]],"start1":179,"start2":179,"length1":17,"length2":21},{"diffs":[[0,"   \""],[-1,"README.md\"\n    ],\n    \"testFiles\": ["],[1,"main.ts\","],[0,"\n   "]],"start1":201,"start2":201,"length1":44,"length2":17},{"diffs":[[0,"   \""],[-1,"test.ts"],[1,"README.md"],[0,"\"\n  "]],"start1":220,"start2":220,"length1":15,"length2":17},{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":243,"start2":243,"length1":32,"length2":31}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1725035138566,"editorVersion":"7.0.25","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"new-extension-clone\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1725035534540}